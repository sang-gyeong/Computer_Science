### 프로토콜

서로 다른 하드웨어와 OS 등을 가진 컴퓨터와 네트워크 기기가 상호간에 통신하기 위해서는 같은 방법으로 통신해야 한다. 이를 위한 규칙을 프로토콜이라고 한다. 

- 케이블 규격, IP 주소 지정 방법 등

## TCP/IP

복수의 프로토콜을 조합한 것이 네트워크 아키텍처인데 그 중 인터넷과 관련된 프로토콜들을 모아놓은 TCP/IP가 가장 많이 사용된다. TCP/IP에서는 네트워크를 통해 통신하기 위한 기능을 계층화하고 복수의 프로토콜을 조합하여 실현된다. '네트워크 인터페이스', '인터넷', '트랜스포트', 애플리케이션'으로 모두 4계층이다.

- 계층화의 이점?
    - 사양이 변경되었을 때 전체를 바꾸지 않고 사양이 변경된 계층만 바꾸면 된다.
    - 자신이 담당하는 부분(역할)만 고려해서 설계하면 된다.

![https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory2&fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F263B4346565471F4158ACD](https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory2&fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F263B4346565471F4158ACD)

### 네트워크 인터페이스 층

같은 네트워크 안에서 데이터를 전송하는 역할 (하나의 네트워크는 라우터와 레이어3 스위치로 구획되는 범위, 또는 레이어2 스위치로 구성하는 범위)

- 디지털 신호를 전기신호 등의 물리적 신호로 변환해 전송 매체로 전달
- 이더넷이나 무선 LAN(Wi-Fi) 등이 이 계층에 속한다

### 인터넷 층

네트워크 사이에서 데이터를 전송하는 역할. 네트워크 상에서 패킷의 이동을 다룬다. 어떠한 경로를 거쳐 상대의 컴퓨터까지 패킷을 보낼지 결정

(네트워크끼리 연결하고 데이터를 전송하는 기기 라우터, 라우터에 의한 네트워크 간 전송을 가리켜 라우팅이라고 한다.)

- IP - 엔드투엔드 통신에 이용하는 프로토콜
- ICMP, ARP - IP를 도와주는 프로토콜

### 트랜스포트 층

데이터를 복수의 애플리케이션 중에서 적절한 애플리케이션에 배분하는 역할.

- TCP - 데이터 재전송, 순서 제어 등으로 엔드투엔드의 신뢰성을 확보해주는 기능
- UDP

### 애플리케이션 층

애플리케이션의 기능을 실행하기 위한 데이터의 형식과 처리 절차 등을 결정

- HTTP, SMTP
- DHCP, DNS - 애플리케이션의 통신을 준비하기 위한 프로토콜

![https://deltamotion.com/support/webhelp/rmcwin/image/ebx_-1705961929.gif](https://deltamotion.com/support/webhelp/rmcwin/image/ebx_-1705961929.gif)


### 데이터 송수신 규칙

각 프로토콜은 각각의 기능을 실현하기 위한 제어 정보(헤더 ex. TCP - 포트 번호)가 필요하다.

- 각 프로토콜은 데이터를 전송할 때 헤더를 추가한다.
- 반대로 프로토콜이 데이터를 수신할 때는 헤더를 적절히 처리해서 벗겨내고 상위 프로토콜로 처리를 넘긴다.

## IP

데이터를 목적지까지 전송한다.


# HTTP (HyperText Transfer Protocol)

- WWW의 환경에서 살아가는 우리는 URL을 이용한다. URL은 다음과 같다 "http://naver.com"
- URL을 통해 누군가에게 무언가를 요청하면, 그에 대한 응답을 전달 받는다. 이때 사용되는 규칙이 HTTP다.
- 그러나 유저가 실제로 HTTP 규칙을 염두해서 요청을 보내진 않는다. URL만 입력한다. HTTP를 염두하는 것은 요청을 보내고 응답을 받는**브라우저**와 같은 **클라이언트 서비스** 응답을 받고 서비스를 진행하는 **서버**의 몫이다.
  - **따라서 HTTP는 애플리케이션 계층에서 사용하는 프로토콜**
- HTTP는 **상태가 없는 프로토콜**이다. 어떠한 데이터(상태)도 유지하지 않기 때문이다. 우리는 HTTP 요청에 있어서 상태를 담고 싶어서 쿠키와 같은 것을 사용하기도 한다.
- HTTP는 일정한 규격을 유지해서 통신하게 된다. HTTP는 보통 **시작줄**, **헤더**와 **본문**으로 구성된다.

- HTTP의 특징
    1) 단방향성
        - 클라이언트가 서버로 요청을 보내고 이에 대한 응답을 받는 단방향적 통신이다.
        - **반드시 클라이언트가 먼저 서버에게 요청을 보내야 하며**, 서버가 클라이언트로 먼저 요청을 보낼 수는 없다.

    2) 비-연결 지향 (Connectionless)

        클라이언트가 서버에게 리소스를 요청한 후 응답을 받으면 연결을 끊어버리는 특징이다

        - **1) 비연결성의 장점**
            - HTTP는 인터넷 상에서 불특정 다수의 통신 환경을 기반으로 설계되었다.
            - 만약 서버에서 다수의 클라이언트와 연결을 계속 유지해야 한다면, 이에 따른 많은 리소스가 발생하게 된다.
            - 따라서 **연결을 유지하기 위한 리소스를 줄이면 더 많은 연결을 할 수 있고, 서버의 부담을 줄일 수 있다.**

        - **2) 비연결성의 단점**

            - 서버는 클라이언트를 기억하고 있지 않으므로 동일한 클라이언트의 모든 요청에 대해, 매번 새로운 연결을 시도/해제의 과정을 거쳐야하므로 **연결/해제에 대한 오버헤드 비용이 발생한다.**

        - **3) KeepAlive**

            - 이를 해결하기 위해선, 요청 헤더의 `Connection: keep-alive` 속성으로 지속적 연결 상태(Persistent connection)를 유지할 수 있다.
            - KeepAlive는 지정된 시간동안 서버와 클라이언트 사이에서 패킷 교환이 없을 경우,상대방의 안부를 묻기위해 패킷을 주기적으로 보내는것을 말한다. 이 때 패킷에 반응이 없으면 접속을 끊게 된다.
            - 즉, 요청을 할 때마다 연결하지 않고 기존의 연결을 재사용하는 방식이다.
            - HTTP 1.1 부턴 지속적 연결 상태가 기본이며, 이를 해제하기 위해선 명시적으로 요청 헤더를 수정해야 한다.
            - 주기적으로 클라이언트의 상태를 체크한다는 것으로 미루어보아 KeepAlive 역시 완벽한 해결책은 아니다. KeepAlive 속성이 On 상태라해도, 서버가 바쁜 환경에서는 프로세스 수가 기하급수적으로 늘어나기 때문에 KeepAlive로 상태를 유지하기 위한 메모리를 많이 사용하게 되므로 주의해야 한다.

    3) **무상태성 (Stateless)**

        - 각각의 요청이 독립적으로 여겨지는 특징으로, **서버는 클라이언트의 상태를 유지하지 않는다.**
        - 즉, 각 클라이언트에 맞게 리소스를 응답하는 것은 불가능하다.
        - 이를 해결하기 위해, 쿠키나 세션 또는 토큰 방식의 OAuth 및 JWT가 사용된다.

<br>

### "HTTP의 비연결성"이라는 개념

우리는 어플리케이션 계층에서 HTTP 프로토콜을 사용하고<br> 트랜스포트 계층에서 **연결 지향적인 TCP** 나 그와 반대인 **UDP**를 사용한다고 알고 있다.

##### 비연결성 HTTP가 어떻게 TCP를 이용할 수 있는가??

- HTTP의 비연결성은 "**이전의 요청과 그 다음의 요청이 연결되어 있지 않다.**"라는 의미다. 즉, 서버와 한 번 연결되었다고 그 통로를 지속하지 않는다는 것이다.
- TCP의 연결성은 "**한 번 연결을 위해, 여러번의 왕복 확인 작업을 진행 한다는 점에서**"나온 말이다.
  - 즉, TCP를 이용하는 HTTP 통신에선,<br> HTTP 요청이 한 번 가면 애플리케이션 계층의 HTTP 프로토콜의 할 일은 끝이다.<br> 아래단에선 TCP가 실제 연결을 확인하기 위한 왕복 작업을 한다.
  - HTTP와 TCP의 계층이 다르기 때문에 서로 역할이 다르다. 따라서, 상반된 성질을 들고 있어도 전혀 문제가 되지 않는다.


<br>
<br>

# Domain

##### IP와 Domain

컴퓨터가 네트워크에 연결되면 host라고 칭하게 된다.<br>
host는 네트워크 상 어디에 존재하는지 논리적인 주소인 IP를 갖게된다. <br>
Domain은 IP와 맵핑된다. Domain이 없으면, 매번 사이트를 들어갈 때마다, ip를 외우고 있어야 하는 번거로움이 생긴다. 편의를 위해 Domain이 등장했다. <br>
우리가 URL 안에 Domain을 입력하면, 브라우저는 Domain을 IP로 변환하려고 하는데, 변환하는 서비스를 해주는 것이 **_DNS_**다.

- 하나의 Domain에 여러개의 IP를 MAPPING 할 수 있다. 이런 경우는 보통 **Load balancing**을 위해서 사용된다. 혹은 하나의 host가 사용 불가능 할 때, 다른 host로 대체하기 위해서 사용한다.

##### URL과 Domain

URL은 Domain을 포함하고 있다.<br>
URL은 http://도메인/aaa/bbb/로 원하는 리소스의 경로를 담고 있는 것이다. <br>

<br>
<br>

# DNS (Domain Name Service)

- Domain을 변환해서, 실제 요청이 도착해야 하는 Host의 네트워크 상 주소(IP)를 반환해주는 서비스다.
- DNS를 제공하는 Server는 **분산 데이터베이스**형태로 구성되어 있다. 그렇지 않으면, 전세계의 요청이 한 곳으로 모이게 되고, 물리적인 거리에 의해 IP 주소를 알아오는데 오랜 시간이 걸리게 된다.
- DNS는 **계층적 구조**를 보인다. 최상위에 위치한 Root DNS Server는 TLD(Top level Domain)이라 불린다.

<br>
<br>

### DNS의 계층적 구조
![](https://i.imgur.com/jG9l5vI.png)
트리 형태를 보인다.<br>
보통 DNS 서버들은 요청마다 발생하는 DNS간 문의를 줄이기 위해, 캐싱한다<br>
캐싱이 내용이 DNS의 변경을 반영하지 못하는 것을 막기 위해, 주기적으로 상위, 하위 DNS에 접근하여 최신 내용으로 업데이트함<br>

1. Root Domain 서버

   - 전 세계에 13개(아마도)로 분산되어 존재한다.
   - 다음 레벨인 최상위 도메인 서버를 관리하는 역할을 한다.

2. TLD(Top Level Domain)최상위 도메인 서버

   - .com, .edu, .net, .kr, .jp 와 같이 우리가 url 제일 마지막에 붙이는 것과 국가의 약어처럼 DNS 서버가 구성되어 있다.
   - naver.com, daum.net과 같이 실제 서비스되는 IP를 들고 있는 서버다.

3. SLD(Second Level Domain)

   - google.co.kr 처럼 .co가 SLD다.
   - gabia.com 처럼, SLD가 존재하지 않을수도 있다.
   - SLD는 도메인의 아이덴티티를 구체화하는 역할을 하는데, 도메인 이름이 짧을 수록 외우기 좋으므로 SLD를 없애는 구조도 존재한다.
     - SLD가 없는 형태의 도메인(도메인 이름.TLD)을 **2단계 도메인**이라 한다.
     - SLD가 있는 형태의 도메인(도메인 이름.SLD.TLD)를 **3단계 도메인**이라 한다.

4. 책임 DNS 서버

   - 하나의 Domain 영역에는 여러개의 host가 존재한다.
   - Domain 안에 www라는 웹 서버(호스트)나, 메일 서버(호스트)가 존재하기 때문에, 요청에 맞는 서버에 보내주기 위해 사용한다.

<br>
<br>

### 로컬 DNS 서버

- 도메인 영역, 예를 들어 hufs.ac.kr 자체에 마련한 DNS 서버다.
- 도메인 영역의 책임 DNS는 host와 요청에 담긴 도착지를 mapping 하는 것이라면, 로컬 DNS는 **IP주소를 캐싱**하는 서버라고 생각하면 된다.
- 한 도메인 영역에서, 외부로 나가는 요청이 발생할 때, 요청 대상의 IP를 캐싱해둬서, 외부로 나가는 통신을 줄일 수 있다.

<br>
<br>

### 브라우저에 naver.com 을 입력하면 벌어지는 일
![](https://i.imgur.com/NwDCdmm.png)

1. 유저가 naver.com을 브라우저에 입력한다.
2. 브라우저는 HTTP 요청을 만들기 위해, naver를 ip로 변환하려 한다.
3. Local DNS에게 질의한다.
4. Local DNS에 캐싱되어 있으면 바로 변환해서 HTTP 메세지를 만들고 요청을 보낸다.
5. 캐싱되어 있지 않으면 Root DNS로 찾아가서 .com DNS의 주소를 알아온다.
6. .com DNS로 가서 naver.com의 DNS 주소를 알아온다.
7. naver.com DNS(**Naver의 책임 DNS**)로 가서, www.naver.com의 **IP**를 알아온다.
   - host를 명시 안하면, 내부적으로 www의 host를 알아온다.
   - 찾은 IP의 MAC주소를 얻기 위해 ARP 프로토콜이 사용된다
8. HTTP 메세지를 만들고 브라우저는 트랜스포트 계층으로 넘긴다.
   - 트랜스포트 계층에선 내부적으로 TCP or UDP 프로토콜에 맞는 데이터를 부가
   - OSI 7계층을 쭉 타고 내려가서 요청이 실제로 전송되는 것

(+) DNS를 알아오는 요청은 일반적으로 UDP다.


----

# Transport Layer

- end to end 연결을 관리하는 계층이다.
- 전송 계층에 도달한 메시지를 App 계층으로 보내는 역할
- 데이터를 쪼개고, TCP/UDP 중 전송 프로토콜에 맞게 메세지를 만드는 역할
  멀티플렉싱: 나눠진 데이터에 헤더를 붙이고, 아래 계층에게 데이터를 내려 보내는 것<br>
  디멀티플렉싱: 도착한 데이터의 전송계층의 헤더를 분석하여, 도착해야하는 앱의 소켓으로 보내는 것

# UDP - Transport Layer Protocol

- Hand Shaking이 없어, 연결을 위한 시간이 필요 없다.
- 대신 연결이 되었는지 신뢰할 수 없다.
- UDP 프로토콜을 사용하면, 데이터그램이 독립적으로 변하여, 데이터의 도착이 비순차적이다.
  - 연결의 신뢰성 확보와, 비순차적인 데이터를 조립하는 것은, App계층에서 담당해야한다.
- 기능이 적기 때문에 Data 크기 대비 헤더의 크기가 작다.

### UDP 헤더 (8 Byte)

1. 출발지 포트 16Bit
2. 도착지 포트 16Bit
3. 데이터의 길이 16Bit (데이터와 헤더를 합친 **패킷**의 크기)
4. 체크섬 16Bit
   - UDP에서 최소한의 **신뢰성**을 위한 장치
   - Sender 측의 전송계층은 Data를 숫자로 파싱하여 Checksum에 담아 보낸다.
   - Receiver 측의 전송계층에서는, 수신된 데이터를 숫자로 파싱하여, 도착한 Checksum과 같은지 확인
   - 이때 두개의 값이 일치하지 않으면 트랜스포트 계층은 해당 데이터를 버린다.(**버리기만 한다.**)
   - 두개의 값이 일치할지라도, 완벽히 신뢰 가능한 데이터는 아니다. 숫자 값은 맞아도 데이터의 일관성을 보장할 수 없기 때문이다.

<br>

### UDP의 디멀티플렉싱

- UDP로 동작하는 App이 여러개일지라도 소켓은 하나다. (TCP는 App마다 각자의 소켓을 갖는다.)
  - 도착지의 전송계층에선, 오직 Port번호로만 소켓을 판단, Port번호만 일치하면 하나의 소켓으로 보내버린다.

<br>
<br>

# TCP - Transport Layer Protocol

- TCP 전송의 경우, 도착지의 전송계층은, 도착한 **패킷의 순서를 맞춰서** 소켓에 올려보낸다.
- 데이터의 손실이 발생하면, 재전송 요청을 보냄으로 신뢰성을 확보한다.
- 혼잡제어, 연결관리, 흐름제어 등의 서비스를 제공하는 프로토콜로 헤더가 크다.

<br>
<br>

### TCP의 신뢰성 있는 전송

1. 전송 중 비트 에러가 발생
2. 도착지에서 Checksum이 일치하지 않는다는 것을 발견
3. TCP는 재전송해야 한다는 사실을 Sender에게 알린다.
   - 이때 사용하는 것이 **ACK/NAK**
   - Receiver는 Checksum이 불일치하면 NAK를 보낸다.
   - Sender는 NAK를 받거나, 아무것도 받지 못하면 **해당 패킷을 다시 보낸다.**

<br>

##### NAK-FREE & Pipeline Protocol

NAK를 받은 Sender는 어떤 패킷이 문제인지 알 수없다.<br>
따라서 NAK를 없애자는 개선안이 등장함(**NAK Free Protocol**)

- ACK에 마지막으로 제대로 수신한 패킷의 번호를 담아보내는 방식
- ACK(0)과 ACK(1)만을 두고, 패킷이 잘 도착했으면 ACK(0)을 전송, 반대면 ACK(1)을 전송한다.
- Sender는 데이터를 보내고 ACK를 기다린다.
  그러나 패킷 하나 보내고 대기하고, 하나 보내고 대기하는 방식에, 재전송 해야하는 상황까지 발생하면 너무 비효율
  <br>

따라서, **Pipeline Protocol** 등장

- 여러 패킷을 순차적으로 일단 다 보내고, ACK가 순차적으로 오는 것을 기다리는 방식을 사용
- 따라서 **BUFFER**가 필요해졌다.
- Sender는 *버퍼에 먼저 저장*하고, *패킷을 전송*한다. ACK가 오는 패킷은 버퍼에서 날린다.
- Receiver는 App 계층에 데이터를 조립해서 보내야 하므로, 버퍼를 두고 조립을 한다.
  - 시퀀스로 잘 도착하면 해당 덩어리를 APP으로 바로 보낸다.
  - 중간에 손실된 데이터가 있으면, 제대로 된 패킷이 올 때까지, 뒤에 있어야하는 패킷들은 버퍼에 남겨둔다.
- Pipeline Protocol에는 **Go-Back-N**방식과 **Selective Repeat**방식이 있다.

<br>
<br>
<br>

### TCP 연결관리

진짜 App 계층에서 내려보낸 데이터를 보내기 전에, 연결을 설정하는 작업을 거친다.<br>
연결 설정은 **연결 요청(SYN)**와**허가 (ACK)**로 구성된다.

##### 2-Way handshaking

1. Client > Server : **SYN**(연결 요청) 전송
2. Server > Client : **ACK**(연결 허락) 전송

**TCP/IP**는 양방향 연결이다. A host가 B host에게 연결을 요청하고 허락을 받아야 하지만, B host는 A host에게 허락을 받아야 하나, 2-way에서는 그렇지 않다.

- 2-way-handshake를 한다면 클라이언트는 서버에게 연결 요청을 하고(1), 서버는 그것에 대한 응답(2)을 함으로써 연결확립이된다. 이 때 만약 서버에 들어온 연결 요청이 사실은 긴 시간지연으로 타이머를 초과해서 재전송된 요청이라면 그리고 클라이언트와 서버의 TCP 통신은 이전에 끝난 상황이라면, 해당 요청은 연결을 확립해주면 안되는 요청이다.(https://kpuls.tistory.com/90)

<br>

##### 3-way handshaking

- 따라서, 서버는 클라이언트의 연결 요청에 대해 다시 한 번 클라이언트가 가용상태(Alive)인지 확인해야한다. 그렇기 때문에 클라이언트가 서버에게 "나는 현재 가용상태이다. " 라고 다시 한 번 서버에게 응답하는 과정이 필요하다.

1. Client > Server : **SYN**(연결 요청) 전송
2. Server > Client : **SYN+ACK**(연결 요청 + 연결 허락) 전송
3. Client > Server : **ACK**(연결 허락)전송
4. 성공적으로 연결되었으니 데이터를 전송한다.

<br>
<br>
<br>

### TCP 흐름제어

흐름제어란 Sender에게 Receiver의 **버퍼 상태**를 알려주면서, 버퍼를 초과하는 상황을 예방하는 것이다.

- Receiver의 전송계층에서, App 계층으로 데이터를 올려보내려 해도, App이 바쁜 경우가 있다.
- 이때, Sender가 데이터 계속 보내게 되면, 버퍼 overflow(**패킷 드롭**)이 발생한다.
- 이것을 예방하고자 흐름제어를 한다.

1. Receiver는 자신이 지금 감당할 수 있는 버퍼 크기를 ACK에 담아 전송한다.
2. Sender는 ACK를 보고, 버퍼에 Receiver가 받을 정도의 패킷만을 담는다.
3. Sender는 App 계층의 프로그램에게, 버퍼에 담지 못한 데이터의 크기를 알려준다.

<br>
<br>
<br>

### TCP 혼잡제어

Sender는 패킷드롭이 발생하지 않는 선에서, 또한 대역폭이 허용하는 선에서,전송률을 최대로 높이려 할 것이다.<br>
Receiver가 아닌 **네트워크 상태**를 고려하여 패킷 드롭이 발생하면 속도를 늦추는 방식이다.

##### 네트워크가 혼잡해지는 사례

1. 여러 개(N)의 호스트들이 공유하는 회선이 있을 때, 회선의 대역폭(R)을 모두 사용하게 되는 순간. 모든 호스트들의 통신에서 패킷드롭이 발생하기 시작한다.
2. 패킷드롭이 발생하게 되면, host들 마다 Timeout이 빈번하게 발생하면서 네트워크 속도는 급격하게 저하된다.
3. 재전송까지 시작되면, 새로 보내는 데이터는 전달조차 되지 않을 가능성이 있다.

- 한 호스트의 속도를 줄여도, 다른 호스트가 빈 대역폭을 차지하려고 하기 때문에 혼잡제어가 불가능해진다.

##### 혼잡 제어 방식

따라서 효율이 떨어지는 순간(패킷 드롭이 발생하는 순간), 회선에 붙은 모든 호스트가 동시에 속도를 줄여야 네트워크 속도를 회복할 수 있다.

1. **끝점간 혼잡 제어**
   혼잡제어는 Transport 계층에서 하는 것이므로, host가 혼잡한 것을 알아서 깨닫고 대응하는 방식이다.
2. **네트워크 지원 혼잡 제어**
   Network 계층의 **라우터**가 끝점의 시스템에 위치한 Sender에가 데이터를 천천히 전송하라고 지시하는 것이다.

<br>
<br>

### UDP VS TCP

- TCP를 이용하는 호스트는 비슷한 속도로 회선을 이용한다.
- TCP는 속도를 점진적으로 증가하다가, 지연이 발생하면(3개의 중복 ACK가 오면 깨닫게 됨) 전송률을 급격히 감소시킨다.
- UDP는 연결을 증가시키는 대로 대역폭을 차지한다. 속도를 높이고 싶으면 UDP 연결 갯수를 늘리면 된다.

- TCP
    - 연결형 프로토콜. 네트워크에 연결된 컴퓨터에서 프로그램 간 일련의 옥텟을 안정적으로, 순서대로, 에러없이 교환할 수 있게 한다.
    - 전송 데이터의 흐름을 제어하고 데이터의 에러 유무를 검사한다.
    - 수신측에서 잘못 전송된 패킷에 대해 재전송 요구
    - 1:1 통신
- UDP
    - 비연결형 프로토콜. 신뢰성을 보장하지 않는 비접속형 통신 제공
    - 메시지 분실 or 송신된 순서와 다른 순서로 수신될 수 있다.
    - 통신 수립 단계가 없어 신속하고 신뢰적이지 못함.
    - 데이터 재전송 X
    - 1:1, 1:n, n:n 통신


# Application Layer

- Application Layer에 위치한 Application들은 Client-Server 구조를 따르거나 P2P 구조를 따른다.

### Socket 소켓

- Application Layer에서는 Socket이 네트워크 기능을 담당한다.
- Application은 web 통신의 HTTP 프로토콜을 지킨 메세지를 Socket에 넘기기도 하며, 도착한 요청을 Socket을 통해 받기도 한다.
- Socket은 Application Layer와 Transport Layer를 잇는 문이다.
- Socket은 프로세스(Application)을 구분하기 위해 **Port**가 사용된다. 요청을 보내고, 응답을 받을 때, 어느 프로세스로 응답을 보내야 할지 구분하기 위함이다.

<br>
<br>

### Application Layer Protocol

- App계층에서 Socket을 통해 메시지를 내리고나서 트랜스포트 계층의 프로토콜(TCP/UDP) 중 선택하는 과정은 왜 보이질 않는가?
- 사용자가 직접 정하는 것이 아니라, 트랜스포트 계층의 프로토콜을 정해둔 응용 프로그램을 사용하고 있기 때문이다. 응용 프로그램이 알아서 달아주기 때문에 보이질 않는 것이다.
- 그래서 보통, App 계층의 프로토콜은 TCP를 사용하는 프로토콜과 UDP를 사용하는 프로토콜로 분리한다.

1. TCP를 사용하는 App 프로토콜: FTP, HTTP, Telnet, SMTP, POP3, IMAP3 등
2. UDP를 사용하는 App 프로토콜: DNS, DHCP, SNMP 등

##### 참고

ssl, https 관련 https://galid1.tistory.com/602?category=746448

---

# Network Layer

### Router

##### 라우터가 하는 일

1. Routing: 라우터들의 상황을 보고 적절한 경로를 결정하는 것(데이터를 어느 회선을 태워서 보낼지)
   - Routing Algorithm의 결과로, "어느 패킷이 어느 회선으로 갈 것인가" **Forwarding table**에 저장된다
2. Forwarding: 라우터의 패킷을 Routing으로 정한 곳으로 내보내는 것

<br>

##### Routing Algorithm

라우팅 알고리즘은 결국 forwarding table을 만드는 것을 목적으로 한다. 라우팅 알고리즘은 두 가지로 나뉜다.

1. **Link State Algorithm**

   - 다익스트라 알고리즘을 사용
   - 주기적으로, 현재 라우터에서 출발하여 그래프를 순회하면서 Forwarding Table을 만든다.
   - 다익스트라 알고리즘을 이용하여, 도착할 라우터와의 최단거리로 내보내게 된다.
   - 네트워크 상황은 실시간으로 변하므로, forwarding table을 주기적으로 갱신해야 한다. 그 **주기는 ISP에서 정한다.**
     - 대부분의 라우터는 ISP나, 지역별로 나뉜다.

2. **Distance Vector Algorithm**
   - 현재위치 -> B 의 경로를 알고 싶을 때, 인접 라우터에게 비용을 물어보고, 그 인접라우터는 자신의 인접라우터에게 비용을 물어보는 방식으로 Forwarding table을 작성한다
   - 마찬가지로 주기적으로 테이블을 갱신해야된다.
     - 주기는 라우터가 결정한다.
     - 자기에게 딸린 회선의 비용이 변경되었음을 감지한 라우터는 인접 라우터에게 forwarding table을 갱신하라고 알려준다.